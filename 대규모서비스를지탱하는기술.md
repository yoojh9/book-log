
# 웹 개발자를 위한 대규모 서비스를 지탱하는 기술

<br>

## 1. 대규모 데이터 처리의 어려운 점
#### 1-1. 메모리 내에서 계산할 수 없다
- 메모리에 올라가지 않으면 기본적으로 디스크를 계속 읽어가면서 검색하게 된다.
- 메모리 내에서 계산할 수 없게되면 디스크에 있는 데이터를 검색할 필요가 있다.
- 디스크는 메모리에 비해 상당히 느리다. 디스크는 느리므로 I/O(Input/Output)에 시간이 걸린다.
- 메모리는 디스크보다 탐색 속도 측면에서 10^5 ~ 10^6배 이상 빠르다

#### 1-2. 디스크는 왜 늦을까?
- 메모리는 전기적인 부품이므로 물리적 구조는 탐색 속도와 그다지 관계 없다.
- 디스크는 동축 상에 '원반'이 쌓여있다. 디스크는 메모리와는 달리 회전 등의 물리적인 동작을 수반한다. 이 물리적인 구조가 탐색 속도에 영향을 준다

#### 1-3. OS 레벨에서의 연구
- OS에서 느린 디스크를 어느정도 커버하기 위한 역할을 하는데, OS에서 연속된 데이터를 디스크의 같은 위치에 쌓는다
- 그 후 데이터를 읽을 때 1 바이트씩 읽는 것이 아니라 4KB(killobytes) 정도를 한꺼번에 읽도록 만들어 디스크의 회전횟수를 최소화 시킨다.

#### 1-4. 전송 속도, 버스의 속도 차
- 탐색 속도 측면에서 메모리가 디스크보다 빠르지만, 전송 속도 측면에서도 차이가 있다.
- 전송 속도는 찾은 데이터를 디스크에서 메모리로 보내거나 메모리에서 CPU로 보내는 등 컴퓨터 내부에서 전송하기 위한 속도이다.
- 메모리나 디스크 모두 CPU와 버스로 연결되어 있다. 이 버스 속도 역시 상당한 차이가 있다.
- SSD는 물리적인 회전이 아니므로 seek(탐색)에는 빠르지만 버스 속도가 병목이 되거나 그 밖에 구조에 기인하는 면이 있어 메모리만큼의 속도는 나오지 않는다.
<br>


## 2. 규모 조정의 요소
#### 2-1. 스케일업, 스케일아웃
- 스케일업(scale-up): 고가의 빠른 하드웨어를 사서 성능을 높이는 전략
- 스케일아웃(scale-out): 저가이면서 일반적인 성능의 하드웨어를 많이 나열에서 시스템 전체 성능을 올리는 전략 (주류)

#### 2-2. CPU 부하와 I/O 부하
- CPU 부하: HTTP 요청을 받아 DB에 질의하고 DB로부터 응답받은 데이터를 가공해서 HTML로 클라이언트에 반환할 때는 기본적으로 CPU 부하만 소요된다
- I/O부하: DB 서버 측면에서는 I/O 부하가 걸린다.

#### 2-3. 웹 어플리케이과 부하의 관계
- Application 서버
  - CPU 부하만 걸리므로 분산이 간단하다. 
  - 기본적으로 데이터를 분산해서 갖고 있는 것이 아니므로 동일한 호스트가 동일하게 작업을 처리하기만 하면 분산할 수 있다. 
  - 따라서 대수만 늘리기만 하면 간단히 확장할 수 있고, 새로운 서버를 추가한 후 요청을 균등하게 분산하기 위해 로드 밸런서(load balancer) 장치를 이용한다
  
- DB 서버
  -만약 1번 서버에서 쓰기가 발생 하였다면 2번 서버는 어떻게 데이터를 동기화 할 것인가에 문제가 생긴다. 
  - 쓰기는 간단히 분산할 수 없다. 또한 어플리케이션 서버는 디스크를 거의 사용하지 않으므로 디스크에 관해서 신경쓰지 않아도 되지만, DB에서는 디스크를 많이 사용하므로 디스크 I/O를 많이 발생 시키는 구성으로 되어 있으면 속도차 문제가 생긴다. 
  - 게다가 데이터가 커질수록 메모리에서 처리하지 못하고 디스크상에서 처리할 수 밖에 없는 요건이 늘어난다.

#### 2-4. CPU 부하와 I/O 부하
- CPU 부하: 대규모의 과학 계산을 수행하는 프로그램이 있는데, '계산을 한다' 라는 것에서 생각할 수 있듯이, 이 프로그램의 처리 속도는 CPU의 계산 속도에 의존하고 있다.
